
# About me ‚ö°

I am a Ruby and C# developer focused on backend systems, especially in API design and system observability

When deciding what to learn next, I think in terms of Information Systems, which include five key parts: hardware, software, data, people, and processes. This helps me stay focused on building a balanced and practical set of skills

---

# My interests üòÅ

#### Backend Development

* API development (Monoliths & Microservices)
* Troubleshooting & observability in distributed systems
* System Design (Scalability, Reliability, Maintainability)
 
#### Data Structures and Algorithms

While my main focus is backend engineering, I regularly work on data structures and algorithms to sharpen my problem-solving skills

---

# Interpersonal Skills üå±

#### Communication

* How am I using Atlassian Confluence effectively? https://kaiquekandykoga.atlassian.net/wiki/x/QwAN

Recommended tools:

* draw.io
* Atlassian Confluence

#### Teamwork

Recommended tools:

* GitHub

#### Problem-solving

* How do I solve complex problems effectively? https://kaiquekandykoga.atlassian.net/wiki/x/twAN

#### Time management

Recommended tools:

* Google Calendar
* Google Sheets

---

# Technical Skills üîß

#### Databases

- **Primary:** PostgreSQL

- **Secondary:** MariaDB, MySQL, SQL Server, Memcached, Redis, SQLite

#### Miscellaneous

Docker, Git, Kubernetes, POSIX utilities (`grep`, `find`, etc.), VirtualBox, tmux

#### Operating systems

- **Primary:** Linux (openSUSE, Debian, Ubuntu, RHEL, Qubes OS, Alpine, NixOS), macOS

- **Secondary:** FreeBSD

#### Programming languages

- **Primary:**
  - **Backend** Ruby, C#, SQL
  - **Frontend** HTML, CSS, JavaScript, TypeScript

- **Secondary:** sh (Bourne Shell), Bash (Bourne Again Shell), PowerShell, Java, C, C++ (Qt)

#### Terminals

- **Primary:** Alacritty, xterm, Warp
- **Secondary:** Kitty

#### Text editors

- **Primary:** Vim, VS Code, Cursor, Zed
- **Secondary:** Emacs

---

# My Learning System üß†

## Choosing a career path

I have identified three approaches to choosing a learning path:
* **Tool-first:** Start by learning a specific tool, then explore the broader areas where that tool is commonly used
* **Area-first:** Begin by studying a particular domain or field, then learn the tools typically used within that area
* **Company-first:** Focus on a specific company, then identify the technologies and domains it emphasizes, and learn accordingly

## Documentation technique

I created a personal learning system to document everything I study. I use `.rb` files to structure knowledge‚Äîwriting class-based notes on tools, languages, and concepts ranging from Vim to GNU Bison to X11. This helps me think through code and organize large amounts of information efficiently

### Example: Vim

```
class Vim
  def grep
    [
      ":grep",
      ":grep colima -r ."
    ]
  end
end
```

### Example: Repositories

```
class Bitbucket
  def private
    [
      # list private repos
    ]
  end

  def public
    [
      # list public repos
    ]
  end
end
```

This approach is inspired by how FreeBSD maintains everything in one tree. I am currently experimenting with managing multiple repositories while keeping my single-repo philosophy

Why do I do it this way?

**Simply because I enjoy it**

---

# My Values ‚ù§Ô∏è

- Respect

- Honesty

---

# Recommended Readings üìï

- Advanced Programming in the UNIX environment Third Edition - W. Richard Stevens and Stephen A. Rago
- Designing Data-Intensive Applications - Martin Kleppmann

---

# Credits üèÜ

Big thanks to Microsoft and the GitHub team for this incredible platform where I can share my work and thoughts freely
